<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>HTTP Client API &mdash; cpp-netlib v0.11.2</title>
    
    <link rel="stylesheet" href="../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.11.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="cpp-netlib v0.11.2" href="../index.html" />
    <link rel="up" title="Reference Manual" href="../reference.html" />
    <link rel="next" title="HTTP Request" href="http_request.html" />
    <link rel="prev" title="Reference Manual" href="../reference.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="http_request.html" title="HTTP Request"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="../reference.html" title="Reference Manual"
             accesskey="P">previous</a> |</li>
        <li><a href="../contents.html">cpp-netlib v0.11.2</a> &raquo;</li>
          <li><a href="../reference.html" accesskey="U">Reference Manual</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="http-client-api">
<h1>HTTP Client API<a class="headerlink" href="#http-client-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="general">
<h2>General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h2>
<p><tt class="xref py py-mod docutils literal"><span class="pre">cpp-netlib</span></tt> includes and implements a number of HTTP clients that you can
use and embed in your own applications. All of the HTTP client implementations:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Cannot be copied.</strong> This means you may have to store instances of the
clients in dynamic memory if you intend to use them as function parameters
or pass them around in smart pointers or by reference.</li>
<li><strong>Assume that requests made are independent of each other.</strong> There currently
is no cookie or session management system built-in to cpp-netlib&#8217;s HTTP client
implementations.</li>
</ul>
</div></blockquote>
<p>The HTTP clients all share the same API, but the internals are documented in
terms of what is different and what to expect with the different
implementations.</p>
<p>As of 0.9.1 the default implementation for the <tt class="xref py py-mod docutils literal"><span class="pre">cpp-netlib</span></tt> HTTP client is
asynchronous.</p>
<p>As of 0.11 the <a class="reference internal" href="#synchronous-clients">Synchronous Clients</a> are now <em>DEPRECATED</em> and will be removed
in subsequent releases.</p>
</div>
<div class="section" id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<p>The HTTP client implementation supports requesting secure HTTP (HTTPS) content
only in the following situations:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Client libraries are built with ``BOOST_NETWORK_ENABLE_HTTPS``.</strong> This
tells the implementation to use HTTPS-specific code to handle HTTPS-based
content when making connections associated with HTTPS URI&#8217;s. This requires
a dependency on <a class="reference external" href="http://www.openssl.org/">OpenSSL</a>.</li>
<li><strong>The ``BOOST_NETWORK_ENABLE_HTTPS`` macro is set when compiling user
code.</strong> It is best to define this either at compile-time of all code using
the library, or before including any of the client headers.</li>
</ul>
</div></blockquote>
<p>To use the client implementations that support HTTPS URIs, you may explicitly
do the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define BOOST_NETWORK_ENABLE_HTTPS</span>
<span class="cp">#include &lt;boost/network/include/http/client.hpp&gt;</span>
</pre></div>
</div>
<p>This forces HTTPS support to be enabled and forces a dependency on <a class="reference external" href="http://www.openssl.org/">OpenSSL</a>.
This dependency is imposed by <a class="reference external" href="http://www.boost.org/libs/asio">Boost.Asio</a></p>
</div>
<div class="section" id="implementations">
<h2>Implementations<a class="headerlink" href="#implementations" title="Permalink to this headline">¶</a></h2>
<p>There is a single user-facing template class named <tt class="docutils literal"><span class="pre">basic_client</span></tt> which takes
three template parameters:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Tag</strong> - which static tag you choose that defines the behavior of the client.</li>
<li><strong>http_version_major</strong> - an unsigned int that defines the HTTP major version
number, this directly affects the HTTP messages sent by the client.</li>
<li><strong>http_version_minor</strong> - an unsigned int that defines the HTTP minor version
number.</li>
</ul>
</div></blockquote>
<p>There are two major different class of implementations of the <tt class="docutils literal"><span class="pre">basic_client</span></tt>
template that depend on which tag you choose: <a class="reference internal" href="#synchronous-clients">Synchronous Clients</a> and
<a class="reference internal" href="#asynchronous-clients">Asynchronous Clients</a>. These two different classes are described in their own
sections following this one. What follows is a table of all tags supported by
the HTTP client implementation provided by <tt class="xref py py-mod docutils literal"><span class="pre">cpp-netlib</span></tt>.</p>
<hr class="docutils" />
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Tag</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>http_default_8bit_tcp_resolve</td>
<td>This is the default HTTP implementation tag
that resolves addresses with a TCP resolver
and provides a synchronous/blocking HTTP
client interface.</td>
</tr>
<tr class="row-odd"><td>http_default_8bit_udp_resolve</td>
<td>This is similar to the above tag except that
it specifies the HTTP client to use a UDP
resolver. It also provides a synchronous/
blocking HTTP client interface.</td>
</tr>
<tr class="row-even"><td>http_keepalive_8bit_tcp_resolve</td>
<td>This tag specifies that the HTTP client by
default will keep connections to the server
alive. It only makes sense if the
<tt class="docutils literal"><span class="pre">version_major</span></tt> and <tt class="docutils literal"><span class="pre">version_minor</span></tt> are
both <tt class="docutils literal"><span class="pre">1</span></tt>, to indicate HTTP 1.1. This tag
causes the HTTP client to resolve using a
TCP resolver and provides a synchronous/
blocking HTTP client interface.</td>
</tr>
<tr class="row-odd"><td>http_keepalive_8bit_udp_resolve</td>
<td>This is similar to the above tag except that
it specifies the HTTP client to use a UDP
resolver. It also provides a synchronous/
blocking HTTP client interface.</td>
</tr>
<tr class="row-even"><td>http_async_8bit_tcp_resolve</td>
<td>This tag provides an active HTTP client
object implementation that uses a TCP
resolver. Response objects returned will
encapsulate a number of <a class="reference external" href="http://www.boost.org/libs/thread">Boost.Thread</a>
shared futures to hold values. Users don&#8217;t
have to see this as they are implementation
details.</td>
</tr>
<tr class="row-odd"><td>http_async_8bit_udp_resolve</td>
<td>This is similar to the above tag except that
specifies the HTTP client to use a UDP
resolver.</td>
</tr>
</tbody>
</table>
<p>In the above table the tags follow a pattern for describing the behavior
introduced by the tags. This pattern is shown below:</p>
<blockquote>
<div>&lt;protocol&gt;_&lt;modifier&gt;_&lt;character-width&gt;_&lt;resolve-strategy&gt;</div></blockquote>
<p>For example, the tag <tt class="docutils literal"><span class="pre">http_default_8bit_tcp_resolve</span></tt> indicates the protocol
<tt class="docutils literal"><span class="pre">http</span></tt>, a modifier <tt class="docutils literal"><span class="pre">default</span></tt>, a character width of <tt class="docutils literal"><span class="pre">8bit</span></tt>, and a resolve
strategy of <tt class="docutils literal"><span class="pre">tcp_resolve</span></tt>.</p>
<div class="section" id="synchronous-clients">
<h3>Synchronous Clients<a class="headerlink" href="#synchronous-clients" title="Permalink to this headline">¶</a></h3>
<p>Of the client tags shown in the table, the following makes the <tt class="docutils literal"><span class="pre">basic_client</span></tt>
behave as a fully synchronous client.</p>
<blockquote>
<div><ul class="simple">
<li><strong>http_default_8bit_tcp_resolve</strong></li>
<li><strong>http_default_8bit_udp_resolve</strong></li>
<li><strong>http_keepalive_8bit_tcp_resolve</strong></li>
<li><strong>http_keepalive_8bit_udp_resolve</strong></li>
</ul>
</div></blockquote>
<p>The synchronous client implements all the operations of the client underneath
the interface all block to wait for I/O to finish. All the member methods are
synchronous and will block until the response object is ready or throws if errors
are encountered in the performance of the HTTP requests.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The synchronous clients are <strong>NOT</strong> thread safe. You will need to do
external synchronization to use synchronous client implementations.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As of version 0.11, all the synchronous client implementations are
deprecated. They will be removed in the next version of the library.</p>
</div>
</div>
<div class="section" id="asynchronous-clients">
<h3>Asynchronous Clients<a class="headerlink" href="#asynchronous-clients" title="Permalink to this headline">¶</a></h3>
<p>The following tags specify the <tt class="docutils literal"><span class="pre">basic_client</span></tt> to behave in an asynchronous
manner:</p>
<blockquote>
<div><ul class="simple">
<li><strong>http_async_8bit_tcp_resolve</strong></li>
<li><strong>http_async_8bit_udp_resolve</strong></li>
</ul>
</div></blockquote>
<p>An asynchronous client implementation means that``basic_client&lt;...&gt;`` is an
<a class="reference external" href="http://en.wikipedia.org/wiki/Active_object">Active Object</a>. This means that the client has and manages its own lifetime
thread, and returns values that are asynchronously filled in. The response
object encapsulates <a class="reference external" href="http://www.boost.org/libs/thread">Boost.Thread</a> futures which get filled in once the values
are available.</p>
<p>The asynchronous clients implement all operations asynchronously which are hidden
from the user. The interface is still synchronous but the fetching of data
happens on a different thread.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The asynchronous clients are thread safe, and can be shared across
many threads. Each request starts a sequence of asynchronous operations
dedicated to that request. The client does not re-cycle connections and uses
a one-request-one-connection model.</p>
</div>
<p>When an asynchronous client object is destroyed, it waits for all pending
asynchronous operations to finish. Errors encountered during operations on
retrieving data from the response objects cause exceptions to be thrown &#8211;
therefore it is best that if a client object is constructed, it should outlive
the response object or be outside the try-catch block handling the errors from
operations on responses. In code, usage should look like the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">http</span><span class="o">::</span><span class="n">client</span> <span class="n">client</span><span class="p">;</span>
<span class="n">try</span> <span class="p">{</span>
  <span class="n">http</span><span class="o">::</span><span class="n">client</span><span class="o">::</span><span class="n">response</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;http://www.example.com/&quot;</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">body</span><span class="p">(</span><span class="n">response</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// deal with exceptions here</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A common mistake is to declare the client inside the try block which invokes
undefined behavior when errors arise from the handling of response objects.
Previous examples cited by the documentation showed the short version of the
code which didn&#8217;t bother moving the <tt class="docutils literal"><span class="pre">http::client</span></tt> object outside of the same
<tt class="docutils literal"><span class="pre">try</span></tt> block where the request/response objects are being used.</p>
</div>
</div>
<div class="section" id="member-functions">
<h2>Member Functions<a class="headerlink" href="#member-functions" title="Permalink to this headline">¶</a></h2>
<p>In this section we assume that the following typedef is in effect:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">network</span><span class="o">::</span><span class="n">http</span><span class="o">::</span><span class="n">basic_client</span><span class="o">&lt;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">network</span><span class="o">::</span><span class="n">http</span><span class="o">::</span><span class="n">tags</span><span class="o">::</span><span class="n">http_default_8bit_udp_resolve</span>
    <span class="p">,</span> <span class="mi">1</span>
    <span class="p">,</span> <span class="mi">1</span>
    <span class="o">&gt;</span>
    <span class="n">client</span><span class="p">;</span>
</pre></div>
</div>
<p>Also, that code using the HTTP client will have use the following header:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;boost/network/include/http/client.hpp&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Starting version 0.9, cpp-netlib clients and server implementations
by default now have an externally-linked component. This is a breaking change
for code that used to rely on cpp-netlib being a header-only library, but can
inhibited by defining the <tt class="docutils literal"><span class="pre">BOOST_NETWORK_NO_LIB</span></tt> preprocessor macro before
including any cpp-netlib header.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Starting version 0.11, cpp-netlib clients and server implementations
no longer support the <tt class="docutils literal"><span class="pre">BOOST_NETWORK_NO_LIB</span></tt> option.</p>
</div>
<div class="section" id="constructors">
<h3>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline">¶</a></h3>
<p>The client implementation can be default constructed, or customized at
initialization.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">client()</span></tt></dt>
<dd>Default constructor.</dd>
<dt><tt class="docutils literal"><span class="pre">explicit</span> <span class="pre">client(client::options</span> <span class="pre">const</span> <span class="pre">&amp;)</span></tt></dt>
<dd>Constructor taking a <tt class="docutils literal"><span class="pre">client_options&lt;Tag&gt;</span></tt> object. The following table
shows the options you can set on a <tt class="docutils literal"><span class="pre">client_options&lt;Tag&gt;</span></tt> instance.</dd>
</dl>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="35%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter Name</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>follow_redirects</td>
<td><tt class="docutils literal"><span class="pre">bool</span></tt></td>
<td>Boolean to specify
whether the client
should follow HTTP
redirects. Default is
<tt class="docutils literal"><span class="pre">false</span></tt>.</td>
</tr>
<tr class="row-odd"><td>cache_resolved</td>
<td><tt class="docutils literal"><span class="pre">bool</span></tt></td>
<td>Boolean to specify
whether the client
should cache resolved
endpoints. The default
is <tt class="docutils literal"><span class="pre">false</span></tt>.</td>
</tr>
<tr class="row-even"><td>io_service</td>
<td><tt class="docutils literal"><span class="pre">shared_ptr&lt;io_service&gt;</span></tt></td>
<td>Shared pointer to a
Boost.Asio
<tt class="docutils literal"><span class="pre">io_service</span></tt>.</td>
</tr>
<tr class="row-odd"><td>openssl_certificate</td>
<td><tt class="docutils literal"><span class="pre">string</span></tt></td>
<td>The filename of the
certificate to load for
the SSL connection for
verification.</td>
</tr>
<tr class="row-even"><td>openssl_verify_path</td>
<td><tt class="docutils literal"><span class="pre">string</span></tt></td>
<td>The directory from
which the certificate
authority files are
located.</td>
</tr>
<tr class="row-odd"><td>always_verify_peer</td>
<td><tt class="docutils literal"><span class="pre">bool</span></tt></td>
<td>Boolean to specify
whether the client
should always verify
peers in SSL connections</td>
</tr>
<tr class="row-even"><td>openssl_certificate_file</td>
<td><tt class="docutils literal"><span class="pre">string</span></tt></td>
<td>Filename of the
certificate to use for
client-side SSL session
establishment.</td>
</tr>
<tr class="row-odd"><td>openssl_private_key_file</td>
<td><tt class="docutils literal"><span class="pre">string</span></tt></td>
<td>Filename of the
private key to use for
client-side SSL session
establishment.</td>
</tr>
<tr class="row-even"><td>timeout</td>
<td><tt class="docutils literal"><span class="pre">int</span></tt></td>
<td>Number of seconds to
wait for client requests
before considering a
timeout has occurred.</td>
</tr>
</tbody>
</table>
<p>To use the above supported named parameters, you&#8217;ll have code that looks like
the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">network</span><span class="o">::</span><span class="n">http</span><span class="p">;</span> <span class="c1">// parameters are in this namespace</span>
<span class="n">client</span><span class="o">::</span><span class="n">options</span> <span class="n">options</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">follow_redirects</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
       <span class="p">.</span><span class="n">cache_resolved</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
       <span class="p">.</span><span class="n">io_service</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&gt;</span><span class="p">())</span>
       <span class="p">.</span><span class="n">openssl_certificate</span><span class="p">(</span><span class="s">&quot;/tmp/my-cert&quot;</span><span class="p">)</span>
       <span class="p">.</span><span class="n">openssl_verify_path</span><span class="p">(</span><span class="s">&quot;/tmp/ca-certs&quot;</span><span class="p">)</span>
       <span class="p">.</span><span class="n">timeout</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">client</span> <span class="nf">client_</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>
<span class="c1">// use client_ as normal from here on out.</span>
</pre></div>
</div>
</div>
<div class="section" id="http-methods">
<h3>HTTP Methods<a class="headerlink" href="#http-methods" title="Permalink to this headline">¶</a></h3>
<p>The client implementation supports various HTTP methods. The following
constructs assume that a client has been properly constructed named <tt class="docutils literal"><span class="pre">client_</span></tt>
and that there is an appropriately constructed request object named <tt class="docutils literal"><span class="pre">request_</span></tt>
and that there is an appropriately constructed response object named
<tt class="docutils literal"><span class="pre">response_</span></tt> like the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">network</span><span class="o">::</span><span class="n">http</span><span class="p">;</span>  <span class="c1">// parameters are here</span>
<span class="n">client</span> <span class="nf">client_</span><span class="p">();</span>
<span class="n">client</span><span class="o">::</span><span class="n">request</span> <span class="n">request_</span><span class="p">(</span><span class="s">&quot;http://cpp-netib.github.com/&quot;</span><span class="p">);</span>
<span class="n">client</span><span class="o">::</span><span class="n">response</span> <span class="n">response_</span><span class="p">;</span>
</pre></div>
</div>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.get(request_)</span></tt></dt>
<dd>Perform an HTTP GET request.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.get(request_,</span> <span class="pre">callback)</span></tt></dt>
<dd>Perform an HTTP GET request, and have the body chunks be handled by the
<tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of <tt class="docutils literal"><span class="pre">callback</span></tt> should be the following:
<tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span> <span class="pre">&amp;,</span> <span class="pre">boost::system::error_code</span> <span class="pre">const</span>
<span class="pre">&amp;)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.head(request_)</span></tt></dt>
<dd>Perform an HTTP HEAD request.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.post(request_)</span></tt></dt>
<dd>Perform an HTTP POST, use the data already set in the request object which
includes the headers, and the body.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.post(request_,</span> <span class="pre">callback)</span></tt></dt>
<dd>Perform an HTTP POST request, and have the body chunks be handled by the
<tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of <tt class="docutils literal"><span class="pre">callback</span></tt> should be the following:
<tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span> <span class="pre">&amp;,</span> <span class="pre">boost::system::error_code</span> <span class="pre">const</span>
<span class="pre">&amp;)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.post(request_,</span> <span class="pre">body)</span></tt></dt>
<dd>Body is a string of type <tt class="docutils literal"><span class="pre">boost::network::string&lt;Tag&gt;::type</span></tt> where <tt class="docutils literal"><span class="pre">Tag</span></tt>
is the HTTP Client&#8217;s <tt class="docutils literal"><span class="pre">Tag</span></tt>. The default content-type used is
<tt class="docutils literal"><span class="pre">x-application/octet-stream</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.post(request_,</span> <span class="pre">body,</span> <span class="pre">callback)</span></tt></dt>
<dd>Body is a string of type <tt class="docutils literal"><span class="pre">boost::network::string&lt;Tag&gt;::type</span></tt> where <tt class="docutils literal"><span class="pre">Tag</span></tt>
is the HTTP Client&#8217;s <tt class="docutils literal"><span class="pre">Tag</span></tt>. The default content-type used is
<tt class="docutils literal"><span class="pre">x-application/octet-stream</span></tt>. Have the response body chunks be handled by
the <tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of <tt class="docutils literal"><span class="pre">callback</span></tt> should be the
following: <tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span> <span class="pre">&amp;,</span>
<span class="pre">boost::system::error_code</span> <span class="pre">const</span> <span class="pre">&amp;)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.post(request_,</span> <span class="pre">body,</span> <span class="pre">content_type)</span></tt></dt>
<dd>The body and content_type parameters are of type
<tt class="docutils literal"><span class="pre">boost::network::string&lt;Tag&gt;::type</span></tt> where <tt class="docutils literal"><span class="pre">Tag</span></tt> is the HTTP Client&#8217;s
<tt class="docutils literal"><span class="pre">Tag</span></tt>. This uses the request object&#8217;s other headers.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.post(request_,</span> <span class="pre">body,</span> <span class="pre">content_type,</span> <span class="pre">callback)</span></tt></dt>
<dd>The body and content_type parameters are of type
<tt class="docutils literal"><span class="pre">boost::network::string&lt;Tag&gt;::type</span></tt> where <tt class="docutils literal"><span class="pre">Tag</span></tt> is the HTTP Client&#8217;s
<tt class="docutils literal"><span class="pre">Tag</span></tt>. This uses the request object&#8217;s other headers. Have the response
body chunks be handled by the <tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of
<tt class="docutils literal"><span class="pre">callback</span></tt> should be the following: <tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span>
<span class="pre">&amp;,</span> <span class="pre">boost::system::error_code</span> <span class="pre">const</span> <span class="pre">&amp;)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.post(request_,</span> <span class="pre">body,</span> <span class="pre">content_type,</span> <span class="pre">callback,</span> <span class="pre">streaming_callback)</span></tt></dt>
<dd>The body and content_type parameters are of type
<tt class="docutils literal"><span class="pre">boost::network::string&lt;Tag&gt;::type</span></tt> where <tt class="docutils literal"><span class="pre">Tag</span></tt> is the HTTP Client&#8217;s
<tt class="docutils literal"><span class="pre">Tag</span></tt>. This uses the request object&#8217;s other headers. Have the response
body chunks be handled by the <tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of
<tt class="docutils literal"><span class="pre">callback</span></tt> should be the following: <tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span>
<span class="pre">&amp;,</span> <span class="pre">boost::system::error_code</span> <span class="pre">const</span> <span class="pre">&amp;)</span></tt>. The <tt class="docutils literal"><span class="pre">streaming_callback</span></tt>
argument should have a which has a signature of the form:
<tt class="docutils literal"><span class="pre">bool(string_type&amp;)</span></tt>. The provided <tt class="docutils literal"><span class="pre">string_type&amp;</span></tt> will be streamed as
soon as the function returns. A return value of <tt class="docutils literal"><span class="pre">false</span></tt> signals the
client that the most recent invocation is the last chunk to be sent.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.post(request_,</span> <span class="pre">streaming_callback)</span></tt></dt>
<dd>Perform and HTTP POST request, and have the request&#8217;s body chunks be
generated by the <tt class="docutils literal"><span class="pre">streaming_callback</span></tt> which has a signature of the form:
<tt class="docutils literal"><span class="pre">bool(string_type&amp;)</span></tt>. The provided <tt class="docutils literal"><span class="pre">string_type&amp;</span></tt> will be streamed as
soon as the function returns. A return value of <tt class="docutils literal"><span class="pre">false</span></tt> signals the client
that the most recent invocation is the last chunk to be sent.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.post(request_,</span> <span class="pre">callback,</span> <span class="pre">streaming_callback)</span></tt></dt>
<dd>Perform an HTTP POST request, and have the body chunks be handled by the
<tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of <tt class="docutils literal"><span class="pre">callback</span></tt> should be the
following: <tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span> <span class="pre">&amp;,</span>
<span class="pre">boost::system::error_code</span> <span class="pre">const</span> <span class="pre">&amp;)</span></tt>. This form also has the request&#8217;s body
chunks be generated by the <tt class="docutils literal"><span class="pre">streaming_callback</span></tt> which has a signature of
the form: <tt class="docutils literal"><span class="pre">bool(string_type&amp;)</span></tt>. The provided <tt class="docutils literal"><span class="pre">string_type&amp;</span></tt> will be
streamed as soon as the function returns. A return value of <tt class="docutils literal"><span class="pre">false</span></tt>
signals the client that the most recent invocation is the last chunk to be
sent.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.put(request_)</span></tt></dt>
<dd>Perform an HTTP PUT, use the data already set in the request object which
includes the headers, and the body.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.put(request_,</span> <span class="pre">callback)</span></tt></dt>
<dd>Perform an HTTP PUT request, and have the body chunks be handled by the
<tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of <tt class="docutils literal"><span class="pre">callback</span></tt> should be the following:
<tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span> <span class="pre">&amp;,</span> <span class="pre">boost::system::error_code</span> <span class="pre">const</span>
<span class="pre">&amp;)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.put(request_,</span> <span class="pre">body)</span></tt></dt>
<dd>Body is a string of type <tt class="docutils literal"><span class="pre">boost::network::string&lt;Tag&gt;::type</span></tt> where <tt class="docutils literal"><span class="pre">Tag</span></tt>
is the HTTP Client&#8217;s <tt class="docutils literal"><span class="pre">Tag</span></tt>. The default content-type used is
<tt class="docutils literal"><span class="pre">x-application/octet-stream</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.put(request_,</span> <span class="pre">body,</span> <span class="pre">callback)</span></tt></dt>
<dd>Body is a string of type <tt class="docutils literal"><span class="pre">boost::network::string&lt;Tag&gt;::type</span></tt> where <tt class="docutils literal"><span class="pre">Tag</span></tt>
is the HTTP Client&#8217;s <tt class="docutils literal"><span class="pre">Tag</span></tt>. The default content-type used is
<tt class="docutils literal"><span class="pre">x-application/octet-stream</span></tt>. Have the response body chunks be handled by
the <tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of <tt class="docutils literal"><span class="pre">callback</span></tt> should be the
following: <tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span> <span class="pre">&amp;,</span>
<span class="pre">boost::system::error_code</span> <span class="pre">const</span> <span class="pre">&amp;)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.put(request_,</span> <span class="pre">body,</span> <span class="pre">content_type)</span></tt></dt>
<dd>The body and content_type parameters are of type
<tt class="docutils literal"><span class="pre">boost::network::string&lt;Tag&gt;::type</span></tt> where <tt class="docutils literal"><span class="pre">Tag</span></tt> is the HTTP Client&#8217;s
<tt class="docutils literal"><span class="pre">Tag</span></tt>. This uses the request object&#8217;s other headers.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.put(request_,</span> <span class="pre">body,</span> <span class="pre">content_type,</span> <span class="pre">callback)</span></tt></dt>
<dd>The body and content_type parameters are of type
<tt class="docutils literal"><span class="pre">boost::network::string&lt;Tag&gt;::type</span></tt> where <tt class="docutils literal"><span class="pre">Tag</span></tt> is the HTTP Client&#8217;s
<tt class="docutils literal"><span class="pre">Tag</span></tt>. This uses the request object&#8217;s other headers. Have the response
body chunks be handled by the <tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of
<tt class="docutils literal"><span class="pre">callback</span></tt> should be the following: <tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span>
<span class="pre">&amp;,</span> <span class="pre">boost::system::error_code</span> <span class="pre">const</span> <span class="pre">&amp;)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.put(request_,</span> <span class="pre">body,</span> <span class="pre">content_type,</span> <span class="pre">callback,</span> <span class="pre">streaming_callback)</span></tt></dt>
<dd>The body and content_type parameters are of type
<tt class="docutils literal"><span class="pre">boost::network::string&lt;Tag&gt;::type</span></tt> where <tt class="docutils literal"><span class="pre">Tag</span></tt> is the HTTP Client&#8217;s
<tt class="docutils literal"><span class="pre">Tag</span></tt>. This uses the request object&#8217;s other headers. Have the response
body chunks be handled by the <tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of
<tt class="docutils literal"><span class="pre">callback</span></tt> should be the following: <tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span>
<span class="pre">&amp;,</span> <span class="pre">boost::system::error_code</span> <span class="pre">const</span> <span class="pre">&amp;)</span></tt>. This form also has the request&#8217;s body
chunks be generated by the <tt class="docutils literal"><span class="pre">streaming_callback</span></tt> which has a signature of
the form: <tt class="docutils literal"><span class="pre">bool(string_type&amp;)</span></tt>. The provided <tt class="docutils literal"><span class="pre">string_type&amp;</span></tt> will be
streamed as soon as the function returns. A return value of <tt class="docutils literal"><span class="pre">false</span></tt>
signals the client that the most recent invocation is the last chunk to be
sent</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.put(request_,</span> <span class="pre">streaming_callback)</span></tt></dt>
<dd>Perform and HTTP PUT request, and have the request&#8217;s body chunks be
generated by the <tt class="docutils literal"><span class="pre">streaming_callback</span></tt> which has a signature of the form:
<tt class="docutils literal"><span class="pre">bool(string_type&amp;)</span></tt>. The provided <tt class="docutils literal"><span class="pre">string_type&amp;</span></tt> will be streamed as
soon as the function returns. A return value of <tt class="docutils literal"><span class="pre">false</span></tt> signals the client
that the most recent invocation is the last chunk to be sent.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.put(request_,</span> <span class="pre">callback,</span> <span class="pre">streaming_callback)</span></tt></dt>
<dd>Perform an HTTP PUT request, and have the body chunks be handled by the
<tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of <tt class="docutils literal"><span class="pre">callback</span></tt> should be the
following: <tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span> <span class="pre">&amp;,</span>
<span class="pre">boost::system::error_code</span> <span class="pre">const</span> <span class="pre">&amp;)</span></tt>. This form also has the request&#8217;s body
chunks be generated by the <tt class="docutils literal"><span class="pre">streaming_callback</span></tt> which has a signature of
the form: <tt class="docutils literal"><span class="pre">bool(string_type&amp;)</span></tt>. The provided <tt class="docutils literal"><span class="pre">string_type&amp;</span></tt> will be
streamed as soon as the function returns. A return value of <tt class="docutils literal"><span class="pre">false</span></tt>
signals the client that the most recent invocation is the last chunk to be
sent.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.delete_(request_)</span></tt></dt>
<dd>Perform an HTTP DELETE request.</dd>
<dt><tt class="docutils literal"><span class="pre">response_</span> <span class="pre">=</span> <span class="pre">client_.delete_(request_,</span> <span class="pre">body_handler=callback)</span></tt></dt>
<dd>Perform an HTTP DELETE request, and have the response body chunks be handled
by the <tt class="docutils literal"><span class="pre">callback</span></tt> parameter. The signature of <tt class="docutils literal"><span class="pre">callback</span></tt> should be the
following: <tt class="docutils literal"><span class="pre">void(iterator_range&lt;char</span> <span class="pre">const</span> <span class="pre">*&gt;</span> <span class="pre">const</span> <span class="pre">&amp;,</span>
<span class="pre">boost::system::error_code</span> <span class="pre">const</span> <span class="pre">&amp;)</span></tt>.</dd>
</dl>
</div>
<div class="section" id="client-specific">
<h3>Client-Specific<a class="headerlink" href="#client-specific" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">client_.clear_resolved_cache()</span></tt></dt>
<dd>Clear the cache of resolved endpoints.</dd>
</dl>
</div>
<div class="section" id="streaming-body-handler">
<h3>Streaming Body Handler<a class="headerlink" href="#streaming-body-handler" title="Permalink to this headline">¶</a></h3>
<p>As of v0.9.1 the library now offers a way to support a streaming body callback
function in all HTTP requests that expect a body part (GET, PUT, POST, DELETE).
A convenience macro is also provided to make callback handlers easier to write.
This macro is called <tt class="docutils literal"><span class="pre">BOOST_NETWORK_HTTP_BODY_CALLBACK</span></tt> which allows users to
write the following code to easily create functions or function objects that
are compatible with the callback function requirements.</p>
<p>An example of how to use the macro is shown below:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">body_handler</span> <span class="p">{</span>
    <span class="k">explicit</span> <span class="n">body_handler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">body</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">body</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">BOOST_NETWORK_HTTP_BODY_CALLBACK</span><span class="p">(</span><span class="k">operator</span><span class="p">(),</span> <span class="n">range</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// in here, range is the Boost.Range iterator_range, and error is</span>
        <span class="c1">// the Boost.System error code.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
            <span class="n">body</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">range</span><span class="p">),</span> <span class="n">boost</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">range</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">body</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// somewhere else</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">some_string</span><span class="p">;</span>
<span class="n">response_</span> <span class="o">=</span> <span class="n">client_</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">request</span><span class="p">(</span><span class="s">&quot;http://cpp-netlib.github.com/&quot;</span><span class="p">),</span>
                        <span class="n">body_handler</span><span class="p">(</span><span class="n">some_string</span><span class="p">));</span>
</pre></div>
</div>
<p>You can also use if for standalone functions instead if you don&#8217;t want or need
to create a function object.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">BOOST_NETWORK_HTTP_BODY_CALLBACK</span><span class="p">(</span><span class="n">print_body</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Received &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">range</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bytes.&quot;</span>
                  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">error</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// somewhere else</span>
<span class="n">response_</span> <span class="o">=</span> <span class="n">client_</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">request</span><span class="p">(</span><span class="s">&quot;http://cpp-netlib.github.com/&quot;</span><span class="p">),</span>
                        <span class="n">print_body</span><span class="p">);</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">BOOST_NETWORK_HTTP_BODY_CALLBACK</span></tt> macro is defined in
<tt class="docutils literal"><span class="pre">boost/network/protocol/http/client/macros.hpp</span></tt>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">HTTP Client API</a><ul>
<li><a class="reference internal" href="#general">General</a></li>
<li><a class="reference internal" href="#features">Features</a></li>
<li><a class="reference internal" href="#implementations">Implementations</a><ul>
<li><a class="reference internal" href="#synchronous-clients">Synchronous Clients</a></li>
<li><a class="reference internal" href="#asynchronous-clients">Asynchronous Clients</a></li>
</ul>
</li>
<li><a class="reference internal" href="#member-functions">Member Functions</a><ul>
<li><a class="reference internal" href="#constructors">Constructors</a></li>
<li><a class="reference internal" href="#http-methods">HTTP Methods</a></li>
<li><a class="reference internal" href="#client-specific">Client-Specific</a></li>
<li><a class="reference internal" href="#streaming-body-handler">Streaming Body Handler</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../reference.html"
                        title="previous chapter">Reference Manual</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="http_request.html"
                        title="next chapter">HTTP Request</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="http_request.html" title="HTTP Request"
             >next</a></li>
        <li class="right" >
          <a href="../reference.html" title="Reference Manual"
             >previous</a> |</li>
        <li><a href="../contents.html">cpp-netlib v0.11.2</a> &raquo;</li>
          <li><a href="../reference.html" >Reference Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008-2014, Glyn Matthews, Dean Michael Berris; 2013 Google, Inc..
      Last updated on Aug 27, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>